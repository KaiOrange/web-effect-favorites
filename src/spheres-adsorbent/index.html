<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="https://kai666666.com/images/apple-touch-icon-next.png?v=5.1.4">
  <link rel="icon" type="image/png" sizes="32x32" href="https://kai666666.com/images/favicon-32x32-next.png?v=5.1.4">
  <link rel="icon" type="image/png" sizes="16x16" href="https://kai666666.com/images/favicon-16x16-next.png?v=5.1.4">
  <title>球体吸附效果</title>
  <style>
    body {
      margin: 0;
      width: 100%;
      height: 100%;
    }

    canvas {
      display: block;
    }

  </style>  
</head>
<body>

  <canvas id="canvas"></canvas>

  <script src='https://cdn.jsdelivr.net/npm/three@0.120/build/three.min.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/three@0.120/examples/js/controls/OrbitControls.js'></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js'></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.3/chroma.min.js'></script>

  <script type="text/javascript">
    const {
      AmbientLight,
      Color,
      DynamicDrawUsage,
      InstancedBufferAttribute,
      InstancedMesh,
      MathUtils,
      Mesh,
      MeshPhongMaterial,
      Object3D,
      Scene,
      SphereBufferGeometry,
      SpotLight,
      Vector2,
      Vector3,
      Plane,
      Raycaster,
      WebGLRenderer,
      PerspectiveCamera,
      OrbitControls,
    } = THREE;

    function useThree() {
      // default conf
      const conf = {
        canvas: null,
        antialias: true,
        alpha: false,
        camera_fov: 50,
        camera_pos: new Vector3(0, 0, 100),
        camera_ctrl: false,
        mouse_move: false,
        mouse_raycast: false,
        window_resize: true,
      };

      // size
      const size = {
        width: 0, height: 0,
        wWidth: 0, wHeight: 0,
        ratio: 0,
      };

      // mouse tracking
      const mouse = new Vector2();
      const mouseV3 = new Vector3();
      const mousePlane = new Plane(new Vector3(0, 0, 1), 0);
      const raycaster = new Raycaster();

      // returned object
      const obj = {
        conf,
        renderer: null,
        camera: null,
        cameraCtrl: null,
        size,
        mouse, mouseV3,
        init,
        dispose,
        setSize,
      };

      /**
      * init three
      */
      function init(params) {
        if (params) {
          for (const [key, value] of Object.entries(params)) {
            conf[key] = value;
          }
        }

        obj.renderer = new WebGLRenderer({ canvas: conf.canvas, antialias: conf.antialias, alpha: conf.alpha });

        obj.camera = new PerspectiveCamera(conf.camera_fov);
        obj.camera.position.copy(conf.camera_pos);

        if (conf.camera_ctrl) {
          obj.cameraCtrl = new OrbitControls(obj.camera, obj.renderer.domElement);
          if (conf.camera_ctrl instanceof Object) {
            for (const [key, value] of Object.entries(conf.camera_ctrl)) {
              obj.cameraCtrl[key] = value;
            }
          }
        }

        if (conf.window_resize) {
          onResize();
          window.addEventListener('resize', onResize);
        }

        if (conf.mouse_move) {
          obj.renderer.domElement.addEventListener('mousemove', onMousemove);
          obj.renderer.domElement.addEventListener('mouseleave', onMouseleave);
        }

        return obj;
      };

      /**
      * remove listeners
      */
      function dispose() {
        window.removeEventListener('resize', onResize);
        obj.renderer.domElement.removeEventListener('mousemove', onMousemove);
        obj.renderer.domElement.removeEventListener('mouseleave', onMouseleave);
      }

      /**
      * mousemove listener
      */
      function onMousemove(e) {
        mouse.x = (e.clientX / size.width) * 2 - 1;
        mouse.y = -(e.clientY / size.height) * 2 + 1;
        updateMouseV3();
      }

      /**
      * mouseleave listener
      */
      function onMouseleave(e) {
        mouse.x = 0;
        mouse.y = 0;
        updateMouseV3();
      }

      /**
      * get 3d mouse position
      */
      function updateMouseV3() {
        if (conf.mouse_raycast) {
          const v3 = new Vector3();
          obj.camera.getWorldDirection(v3);
          mousePlane.normal.copy(v3.normalize());
          raycaster.setFromCamera(mouse, obj.camera);
          raycaster.ray.intersectPlane(mousePlane, mouseV3);
        }
      }

      /**
      * resize listener
      */
      function onResize() {
        setSize(window.innerWidth, window.innerHeight);
      }

      /**
      * update renderer size and camera
      */
      function setSize(width, height) {
        size.width = width;
        size.height = height;
        size.ratio = width / height;

        obj.renderer.setSize(width, height, false);
        obj.camera.aspect = size.ratio;
        obj.camera.updateProjectionMatrix();

        const wsize = getCameraSize();
        size.wWidth = wsize[0]; size.wHeight = wsize[1];
      }

      /**
      * calculate camera visible area size
      */
      function getCameraSize() {
        const vFOV = (obj.camera.fov * Math.PI) / 180;
        const h = 2 * Math.tan(vFOV / 2) * Math.abs(obj.camera.position.z);
        const w = h * obj.camera.aspect;
        return [w, h];
      }

      return obj;
    }

    const { randFloat: rnd, randFloatSpread: rndFS } = MathUtils;

    App();

    function App() {
      let three, scene;
      let cannon, iMesh;

      const target = new Vector3();
      let sphere, light1, light2;

      init();
      

      function init() {
        three = useThree().init({
          canvas: document.getElementById('canvas'),
          camera_fov: 50,
          camera_pos: new Vector3(0, 0, 25),
          camera_ctrl: {
            enableDamping: true,
            dampingFactor: 0.05,
          },
          mouse_move: true,
          mouse_raycast: true,
        });
        three.renderer.shadowMap.enabled = true;

        cannon = useCannon();

        initScene();
        animate();
      }

      function initScene() {
        scene = new Scene();

        scene.background = new Color(0xffffff);
        scene.add(new AmbientLight(0x808080));

        light1 = new SpotLight(0xffffff, 0.5, 0, Math.PI / 8, 0.1);
        light1.position.set(0, 20, 50);
        light1.castShadow = true;
        light1.shadow.mapSize.width = 2048;
        light1.shadow.mapSize.height = 2048;
        scene.add(light1);
        scene.add(light1.target);

        light2 = new SpotLight(0xff0000, 0.5, 0, Math.PI / 8, 0.1);
        light2.position.set(0, -20, 50);
        light2.castShadow = true;
        light2.shadow.mapSize.width = 2048;
        light2.shadow.mapSize.height = 2048;
        scene.add(light2);
        scene.add(light2.target);

        sphere = new Mesh(
          new SphereBufferGeometry(5, 24, 24),
          new MeshPhongMaterial({ color: 0xffffff })
        );
        sphere.receiveShadow = true;
        scene.add(sphere);
        cannon.addMesh(sphere);

        initInstancedMesh();
      }

      function initInstancedMesh() {
        const geometry = new SphereBufferGeometry(1, 16, 16);
        // const geometry = new BoxBufferGeometry(1, 1, 1);
        const material = new MeshPhongMaterial({ color: 0xffffff, vertexColors: true });
        iMesh = new InstancedMesh(geometry, material, 200);
        iMesh.instanceMatrix.setUsage(DynamicDrawUsage);
        iMesh.mass = 0.1;

        iMesh.castShadow = true;
        iMesh.receiveShadow = true;

        // instance matrix
        const dummy = new Object3D();
        iMesh.scales = new Float32Array(iMesh.count);
        for (let i = 0; i < iMesh.count; i++) {
          dummy.position.set(rndFS(40), rndFS(40), rndFS(40));
          dummy.updateMatrix();
          iMesh.setMatrixAt(i, dummy.matrix);
          iMesh.scales[i] = rnd(0.25, 1);
        }

        // colors
        const cscale = chroma.scale([0xffffff, 0xc5777c, 0x437b7f]);
        iMesh.cscale = cscale;
        const colors = [];
        for (let i = 0; i < iMesh.count; i++) {
          const color = new Color(cscale(rnd(0, 1)).hex());
          colors.push(color.r, color.g, color.b);
        }
        iMesh.geometry.setAttribute('color', new InstancedBufferAttribute(new Float32Array(colors), 3));

        scene.add(iMesh);
        cannon.addMesh(iMesh);

        // custom gravity
        const v = new Vector3();
        iMesh.bodies.forEach(body => {
          body.preStep = () => {
            v.copy(target).sub(body.position).normalize().multiplyScalar(0.5);
            v.clampScalar(-0.5, 0.5);
            body.force.copy(v);
          };
        });
      }

      function animate() {
        requestAnimationFrame(animate);
        target.copy(three.mouseV3);
        cannon.step();
        render();
      }

      function render() {
        const { renderer, camera, cameraCtrl } = three;
        if (cameraCtrl) cameraCtrl.update();
        renderer.render(scene, camera);
      }
    }

    /**
    * From https://github.com/mrdoob/three.js/blob/master/examples/jsm/physics/CannonPhysics.js
    */
    function useCannon() {
      const world = new CANNON.World();
      world.gravity.set(0, 0, 0);
      // world.broadphase = new CANNON.SAPBroadphase(world);
      world.broadphase = new CANNON.NaiveBroadphase();
      world.solver.iterations = 20;

      const meshes = [];

      const obj = {
        world,
        addMesh,
        step,
      };

      function addMesh(mesh) {
        const shape = getShape(mesh.geometry);
        if (shape) {
          if (mesh.isInstancedMesh) {
            handleInstancedMesh(mesh, shape);
          } else if (mesh.isMesh) {
            handleMesh(mesh, shape);
          }
        }
      }

      function step(mesh) {
        world.step(1 / 60);
        for (let i = 0, l = meshes.length; i < l; i++) {
          const mesh = meshes[i];
          if (mesh.isInstancedMesh) {
            const iMatrix = mesh.instanceMatrix.array;
            const bodies = mesh.bodies;
            for (let j = 0; j < bodies.length; j++) {
              const body = bodies[j];
              compose(body.position, body.quaternion, mesh.scales[j], iMatrix, j * 16);
            }
            mesh.instanceMatrix.needsUpdate = true;
          } else if (mesh.isMesh) {
            mesh.position.copy(mesh.body.position);
            mesh.quaternion.copy(mesh.body.quaternion);
          }
        }
      };

      function getShape(geometry) {
        const parameters = geometry.parameters;
        switch (geometry.type) {
          case 'BoxBufferGeometry':
            const boxParams = new CANNON.Vec3();
            boxParams.x = parameters.width / 2;
            boxParams.y = parameters.height / 2;
            boxParams.z = parameters.depth / 2;
            return new CANNON.Box(boxParams);

          case 'PlaneBufferGeometry':
            return new CANNON.Plane();

          case 'SphereBufferGeometry':
            return new CANNON.Sphere(parameters.radius);

          case 'CylinderBufferGeometry':
            return new CANNON.Cylinder(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments);
        }
        return null;
      };

      function handleMesh(mesh, shape) {
        const position = new CANNON.Vec3();
        position.copy(mesh.position);

        const quaternion = new CANNON.Quaternion();
        quaternion.copy(mesh.quaternion);

        const body = new CANNON.Body({ position, quaternion, mass: mesh.mass, shape });
        world.addBody(body);

        if (mesh.mass > 0) {
          mesh.body = body;
          meshes.push(mesh);
        }
      };

      function handleInstancedMesh(mesh, shape) {
        const iMatrix = mesh.instanceMatrix.array;
        const bodies = [];
        for (let i = 0; i < mesh.count; i++) {
          const index = i * 16;

          const position = new CANNON.Vec3();
          position.set(iMatrix[index + 12], iMatrix[index + 13], iMatrix[index + 14]);

          // handle instance scale
          const scale = mesh.scales[i];
          const geoParams = mesh.geometry.parameters;
          if (mesh.geometry.type === 'SphereBufferGeometry') {
            shape = new CANNON.Sphere(scale * geoParams.radius);
          } else if (mesh.geometry.type === 'BoxBufferGeometry') {
            shape = new CANNON.Box(new CANNON.Vec3(
              scale * geoParams.width / 2,
              scale * geoParams.height / 2,
              scale * geoParams.depth / 2
            ));
          }
          const mass = scale * mesh.mass;
          const damping = 0.1; // mass * 0.1;
          const body = new CANNON.Body({ position, mass, shape, linearDamping: damping, angularDamping: damping });

          world.addBody(body);
          bodies.push(body);
        }

        if (mesh.mass > 0) {
          mesh.bodies = bodies;
          meshes.push(mesh);
        }
      };

      function compose(position, quaternion, scale, iMatrix, index) {
        const x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;

        iMatrix[index + 0] = (1 - (yy + zz)) * scale;
        iMatrix[index + 1] = (xy + wz) * scale;
        iMatrix[index + 2] = (xz - wy) * scale;
        iMatrix[index + 3] = 0;

        iMatrix[index + 4] = (xy - wz) * scale;
        iMatrix[index + 5] = (1 - (xx + zz)) * scale;
        iMatrix[index + 6] = (yz + wx) * scale;
        iMatrix[index + 7] = 0;

        iMatrix[index + 8] = (xz + wy) * scale;
        iMatrix[index + 9] = (yz - wx) * scale;
        iMatrix[index + 10] = (1 - (xx + yy)) * scale;
        iMatrix[index + 11] = 0;

        iMatrix[index + 12] = position.x;
        iMatrix[index + 13] = position.y;
        iMatrix[index + 14] = position.z;
        iMatrix[index + 15] = 1;
      }

      return obj;
    }

  </script>
</body>
</html>